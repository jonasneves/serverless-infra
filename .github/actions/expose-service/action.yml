name: Expose Service
description: Run a container and expose it via Cloudflare Tunnel

inputs:
  image:
    description: 'Docker image to pull and run'
    required: false
  dockerfile:
    description: 'Path to Dockerfile to build and run'
    required: false
    default: ''
  port:
    description: 'Port the container exposes'
    required: true
  env:
    description: 'Environment variables (KEY=value, one per line)'
    required: false
    default: ''
  wait_time:
    description: 'Seconds to wait for tunnel establishment'
    required: false
    default: '10'
  health_check:
    description: 'HTTP path for health check (e.g., /health)'
    required: false
    default: ''
  max_health_attempts:
    description: 'Maximum health check attempts'
    required: false
    default: '30'
  tunnel_token:
    description: 'Cloudflare Tunnel token for managed tunnels'
    required: false
    default: ''
  tunnel_url:
    description: 'Public URL for managed tunnel (required if tunnel_token is provided)'
    required: false
    default: ''
  keep_alive:
    description: 'Monitor and restart crashed containers (for continuous hosting)'
    required: false
    default: 'false'
  duration:
    description: 'Duration to run in hours (used with keep_alive)'
    required: false
    default: '5.5'

outputs:
  url:
    description: 'Public tunnel URL'
    value: ${{ steps.tunnel.outputs.url }}
  container_id:
    description: 'Container ID'
    value: ${{ steps.container.outputs.id }}
  mode:
    description: 'Tunnel mode (quick or managed)'
    value: ${{ steps.tunnel.outputs.mode }}

runs:
  using: composite
  steps:
    - name: Validate inputs
      shell: bash
      run: |
        if [ -z "${{ inputs.image }}" ] && [ -z "${{ inputs.dockerfile }}" ]; then
          echo "Error: Either 'image' or 'dockerfile' must be provided"
          exit 1
        fi
        if [ -n "${{ inputs.image }}" ] && [ -n "${{ inputs.dockerfile }}" ]; then
          echo "Error: Provide either 'image' or 'dockerfile', not both"
          exit 1
        fi

    - name: Build image
      if: inputs.dockerfile != ''
      shell: bash
      run: |
        docker build -t app:local -f "${{ inputs.dockerfile }}" .
        echo "Built image from ${{ inputs.dockerfile }}"

    - name: Pull image
      if: inputs.image != ''
      shell: bash
      run: |
        docker pull ${{ inputs.image }}
        echo "Pulled ${{ inputs.image }}"

    - name: Start container
      id: container
      shell: bash
      env:
        CONTAINER_ENV: ${{ inputs.env }}
      run: |
        IMAGE="${{ inputs.image }}"
        [ -z "$IMAGE" ] && IMAGE="app:local"

        ENV_ARGS=""
        if [ -n "$CONTAINER_ENV" ]; then
          while IFS= read -r line; do
            [ -n "$line" ] && ENV_ARGS="$ENV_ARGS -e $line"
          done <<< "$CONTAINER_ENV"
        fi

        CONTAINER_ID=$(docker run -d --name app-container -p ${{ inputs.port }}:${{ inputs.port }} $ENV_ARGS $IMAGE)
        echo "id=$CONTAINER_ID" >> $GITHUB_OUTPUT
        echo "Started container $CONTAINER_ID"

    - name: Health check
      if: inputs.health_check != ''
      shell: bash
      run: |
        for i in $(seq 1 ${{ inputs.max_health_attempts }}); do
          if ! docker ps | grep -q app-container; then
            echo "Container stopped unexpectedly"
            echo ""
            echo "=== Container logs ==="
            docker logs app-container 2>&1
            echo ""
            echo "=== Exit code ==="
            docker inspect app-container --format='{{.State.ExitCode}}'
            echo ""
            echo "=== Memory ==="
            free -h
            exit 1
          fi

          if curl -sf http://localhost:${{ inputs.port }}${{ inputs.health_check }} > /dev/null; then
            echo "Container healthy"
            exit 0
          fi
          echo "Waiting for container... ($i/${{ inputs.max_health_attempts }})"
          sleep 2
        done
        echo "Container failed health check"
        docker logs app-container
        exit 1

    - name: Install cloudflared
      shell: bash
      run: |
        ARCH=$(uname -m)
        if [ "$ARCH" = "aarch64" ] || [ "$ARCH" = "arm64" ]; then
          wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-arm64.deb
          sudo dpkg -i cloudflared-linux-arm64.deb
        else
          wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
          sudo dpkg -i cloudflared-linux-amd64.deb
        fi

    - name: Start tunnel
      id: tunnel
      shell: bash
      env:
        TUNNEL_TOKEN: ${{ inputs.tunnel_token }}
        TUNNEL_URL: ${{ inputs.tunnel_url }}
      run: |
        if [ -n "$TUNNEL_TOKEN" ]; then
          if [ -z "$TUNNEL_URL" ]; then
            echo "Error: tunnel_url is required when using tunnel_token"
            exit 1
          fi

          echo "mode=managed" >> $GITHUB_OUTPUT
          cloudflared tunnel --no-autoupdate run --token "$TUNNEL_TOKEN" > tunnel.log 2>&1 &
          echo $! > /tmp/tunnel.pid

          sleep ${{ inputs.wait_time }}

          if ! ps -p $(cat /tmp/tunnel.pid) > /dev/null; then
            echo "Tunnel process died"
            cat tunnel.log
            exit 1
          fi

          echo "url=$TUNNEL_URL" >> $GITHUB_OUTPUT
          echo "Exposed at: $TUNNEL_URL (managed)"
        else
          echo "mode=quick" >> $GITHUB_OUTPUT
          cloudflared tunnel --url http://localhost:${{ inputs.port }} > tunnel.log 2>&1 &
          echo $! > /tmp/tunnel.pid

          sleep ${{ inputs.wait_time }}

          TUNNEL_URL=$(grep -oP 'https://[^\s]+\.trycloudflare\.com' tunnel.log | head -1)

          if [ -z "$TUNNEL_URL" ]; then
            echo "Failed to get tunnel URL"
            cat tunnel.log
            exit 1
          fi

          echo "url=$TUNNEL_URL" >> $GITHUB_OUTPUT
          echo "Exposed at: $TUNNEL_URL (quick)"
        fi

    - name: Verify tunnel
      shell: bash
      run: |
        TUNNEL_URL="${{ steps.tunnel.outputs.url }}"

        for i in $(seq 1 10); do
          if curl -sf "$TUNNEL_URL" > /dev/null; then
            echo "Tunnel accessible"
            exit 0
          fi
          echo "Waiting for tunnel... ($i/10)"
          sleep 3
        done

        echo "Warning: Tunnel may not be accessible yet"

    - name: Monitor
      if: inputs.keep_alive == 'true'
      shell: bash
      run: |
        cleanup() {
          echo "Shutting down..."
          docker stop app-container 2>/dev/null || true
          docker rm app-container 2>/dev/null || true
          kill $(cat /tmp/tunnel.pid 2>/dev/null) 2>/dev/null || true
          exit 0
        }
        trap cleanup SIGTERM SIGINT

        DURATION_HOURS="${{ inputs.duration }}"
        DURATION=$(echo "$DURATION_HOURS * 3600" | bc | cut -d. -f1)
        START=$(date +%s)

        echo "Monitoring for ${DURATION_HOURS}h"

        while true; do
          ELAPSED=$(($(date +%s) - START))
          REMAINING=$((DURATION - ELAPSED))

          CONTAINER_STATUS=$(docker inspect -f '{{.State.Status}}' app-container 2>/dev/null || echo "stopped")
          TUNNEL_RUNNING=$(ps -p $(cat /tmp/tunnel.pid 2>/dev/null) > /dev/null 2>&1 && echo "running" || echo "stopped")

          printf "[%s] Container: %s | Tunnel: %s | %dm remaining\n" \
            "$(date '+%H:%M:%S')" "$CONTAINER_STATUS" "$TUNNEL_RUNNING" "$((REMAINING/60))"

          if [ "$CONTAINER_STATUS" != "running" ]; then
            echo "Restarting container..."
            docker start app-container || true
          fi

          if [ "$TUNNEL_RUNNING" != "running" ]; then
            echo "Restarting tunnel..."
            if [ -n "${{ inputs.tunnel_token }}" ]; then
              cloudflared tunnel --no-autoupdate run --token "${{ inputs.tunnel_token }}" > tunnel.log 2>&1 &
            else
              cloudflared tunnel --url http://localhost:${{ inputs.port }} > tunnel.log 2>&1 &
            fi
            echo $! > /tmp/tunnel.pid
          fi

          [ $ELAPSED -gt $DURATION ] && break
          sleep 30
        done

        cleanup

    - name: Show logs on failure
      if: failure()
      shell: bash
      run: |
        echo "=== Container logs ==="
        docker logs app-container 2>&1 | tail -100 || true
        echo ""
        echo "=== Tunnel logs ==="
        cat tunnel.log 2>&1 | tail -50 || true
